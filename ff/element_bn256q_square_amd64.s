// Code generated by goff (v0.2.1) DO NOT EDIT

#include "textflag.h"

// func Squareelement_bn256q(res,x *element_bn256q)
// montgomery squaring of x
// stores the result in res
TEXT ·Squareelement_bn256q(SB), NOSPLIT, $0-16
    
    // dereference x
    MOVQ x+8(FP), DI
    
    // the algorithm is described here
    // https://hackmd.io/@zkteam/modular_multiplication
    // for i=0 to N-1
    // A, t[i] = x[i] * x[i] + t[i]
    // p = 0
    // for j=i+1 to N-1
    //     p,A,t[j] = 2*x[j]*x[i] + t[j] + (p,A)
    // m = t[0] * q'[0]
    // C, _ = t[0] + q[0]*m
    // for j=1 to N-1
    //     C, t[j-1] = q[j]*m +  t[j] + C
    // t[N-1] = C + A
    
    // check if we support adx and mulx
    CMPB ·supportAdx(SB), $1
    JNE no_adx
    
    // for i=0 to N-1
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 0
    
    // clear up the carry flags
    XORQ R12, R12
    
    // A, t[0] = x[0] * x[0] + t[0]
    MOVQ 0(DI), DX
    
    MULXQ DX, CX , BX   // x[0] * x[0]
    
    // for j=i+1 to N-1
    //     A,t[j] = x[j]*x[i] + t[j] + A
    MOVQ $0, R9
    
    // MOVQ R8, BX
    MULXQ 8(DI), AX,BP
    MOVQ BP, R10 // saving hi bits
    
    ADOXQ AX, AX // doubling lo bits
    ADOXQ R9, BP
    ADOXQ AX, BX
    
    // MOVQ R8, BP
    MULXQ 16(DI), AX,SI
    MOVQ SI, R11 // saving hi bits
    
    ADOXQ AX, AX // doubling lo bits
    ADOXQ R9, SI
    ADOXQ AX, BP
    
    // MOVQ R8, SI
    MULXQ 24(DI), AX,R8
    MOVQ R8, DX // saving hi bits
    
    ADOXQ AX, AX // doubling lo bits
    ADOXQ R9, R8
    ADOXQ AX, SI
    
    // add the last carries to R8
    ADCXQ R9, R8
    ADOXQ R9, R8
    
    ADDQ R10, BP
    ADCQ R11, SI
    ADCQ DX, R8
    
    // m := t[0]*q'[0] mod W
    MOVQ $0x87d20782e4866389, DX
    MULXQ CX,R10, DX
    
    // clear the carry flags
    XORQ DX, DX
    
    // C,_ := t[0] + m*q[0]
    MOVQ $0x3c208c16d87cfd47, DX
    MULXQ R10, AX, DX
    ADCXQ CX ,AX
    MOVQ DX, CX
    
    // for j=1 to N-1
    //    (C,t[j-1]) := t[j] + m*q[j] + C
    MOVQ $0x97816a916871ca8d, DX
    ADCXQ  BX, CX
    MULXQ R10, AX, BX
    ADOXQ AX, CX
    MOVQ $0xb85045b68181585d, DX
    ADCXQ  BP, BX
    MULXQ R10, AX, BP
    ADOXQ AX, BX
    MOVQ $0x30644e72e131a029, DX
    ADCXQ  SI, BP
    MULXQ R10, AX, SI
    ADOXQ AX, BP
    MOVQ $0, AX
    ADCXQ AX, SI
    ADOXQ R8, SI
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 1
    
    // clear up the carry flags
    XORQ R12, R12
    
    // A, t[1] = x[1] * x[1] + t[1]
    MOVQ 8(DI), DX
    
    MULXQ DX, AX, R8   // x[1] * x[1]
    ADCXQ AX, BX
    
    // for j=i+1 to N-1
    //     A,t[j] = x[j]*x[i] + t[j] + A
    MOVQ $0, R9
    
    ADCXQ R8, BP
    MULXQ 16(DI), AX, R8
    MOVQ R8, R10 // saving hi bits
    
    ADOXQ AX, AX // doubling lo bits
    ADOXQ R9, R8
    ADOXQ AX, BP
    
    ADCXQ R8, SI
    MULXQ 24(DI), AX, R8
    MOVQ R8, DX // saving hi bits
    
    ADOXQ AX, AX // doubling lo bits
    ADOXQ R9, R8
    ADOXQ AX, SI
    
    // add the last carries to R8
    ADCXQ R9, R8
    ADOXQ R9, R8
    
    ADDQ R10, SI
    ADCQ DX, R8
    
    // m := t[0]*q'[0] mod W
    MOVQ $0x87d20782e4866389, DX
    MULXQ CX,R10, DX
    
    // clear the carry flags
    XORQ DX, DX
    
    // C,_ := t[0] + m*q[0]
    MOVQ $0x3c208c16d87cfd47, DX
    MULXQ R10, AX, DX
    ADCXQ CX ,AX
    MOVQ DX, CX
    
    // for j=1 to N-1
    //    (C,t[j-1]) := t[j] + m*q[j] + C
    MOVQ $0x97816a916871ca8d, DX
    ADCXQ  BX, CX
    MULXQ R10, AX, BX
    ADOXQ AX, CX
    MOVQ $0xb85045b68181585d, DX
    ADCXQ  BP, BX
    MULXQ R10, AX, BP
    ADOXQ AX, BX
    MOVQ $0x30644e72e131a029, DX
    ADCXQ  SI, BP
    MULXQ R10, AX, SI
    ADOXQ AX, BP
    MOVQ $0, AX
    ADCXQ AX, SI
    ADOXQ R8, SI
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 2
    
    // clear up the carry flags
    XORQ R12, R12
    
    // A, t[2] = x[2] * x[2] + t[2]
    MOVQ 16(DI), DX
    
    MULXQ DX, AX, R8   // x[2] * x[2]
    ADCXQ AX, BP
    
    // for j=i+1 to N-1
    //     A,t[j] = x[j]*x[i] + t[j] + A
    MOVQ $0, R9
    
    ADCXQ R8, SI
    MULXQ 24(DI), AX, R8
    MOVQ R8, DX // saving hi bits
    
    ADOXQ AX, AX // doubling lo bits
    ADOXQ R9, R8
    ADOXQ AX, SI
    
    // add the last carries to R8
    ADCXQ R9, R8
    ADOXQ R9, R8
    
    ADCQ DX, R8
    
    // m := t[0]*q'[0] mod W
    MOVQ $0x87d20782e4866389, DX
    MULXQ CX,R10, DX
    
    // clear the carry flags
    XORQ DX, DX
    
    // C,_ := t[0] + m*q[0]
    MOVQ $0x3c208c16d87cfd47, DX
    MULXQ R10, AX, DX
    ADCXQ CX ,AX
    MOVQ DX, CX
    
    // for j=1 to N-1
    //    (C,t[j-1]) := t[j] + m*q[j] + C
    MOVQ $0x97816a916871ca8d, DX
    ADCXQ  BX, CX
    MULXQ R10, AX, BX
    ADOXQ AX, CX
    MOVQ $0xb85045b68181585d, DX
    ADCXQ  BP, BX
    MULXQ R10, AX, BP
    ADOXQ AX, BX
    MOVQ $0x30644e72e131a029, DX
    ADCXQ  SI, BP
    MULXQ R10, AX, SI
    ADOXQ AX, BP
    MOVQ $0, AX
    ADCXQ AX, SI
    ADOXQ R8, SI
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 3
    
    // clear up the carry flags
    XORQ R12, R12
    
    // A, t[3] = x[3] * x[3] + t[3]
    MOVQ 24(DI), DX
    
    MULXQ DX, AX, R8   // x[3] * x[3]
    ADCXQ AX, SI
    
    // for j=i+1 to N-1
    //     A,t[j] = x[j]*x[i] + t[j] + A
    MOVQ $0, R9
    
    // add the last carries to R8
    ADCXQ R9, R8
    ADOXQ R9, R8
    
    // m := t[0]*q'[0] mod W
    MOVQ $0x87d20782e4866389, DX
    MULXQ CX,R10, DX
    
    // clear the carry flags
    XORQ DX, DX
    
    // C,_ := t[0] + m*q[0]
    MOVQ $0x3c208c16d87cfd47, DX
    MULXQ R10, AX, DX
    ADCXQ CX ,AX
    MOVQ DX, CX
    
    // for j=1 to N-1
    //    (C,t[j-1]) := t[j] + m*q[j] + C
    MOVQ $0x97816a916871ca8d, DX
    ADCXQ  BX, CX
    MULXQ R10, AX, BX
    ADOXQ AX, CX
    MOVQ $0xb85045b68181585d, DX
    ADCXQ  BP, BX
    MULXQ R10, AX, BP
    ADOXQ AX, BX
    MOVQ $0x30644e72e131a029, DX
    ADCXQ  SI, BP
    MULXQ R10, AX, SI
    ADOXQ AX, BP
    MOVQ $0, AX
    ADCXQ AX, SI
    ADOXQ R8, SI
    
    reduce:
    // dereference result
    MOVQ res+0(FP), AX
    // reduce, constant time version
    // first we copy registers storing t in a separate set of registers
    // as SUBQ modifies the 2nd operand
    MOVQ CX, DX
    MOVQ BX, DI
    MOVQ BP, R8
    MOVQ SI, R9
    MOVQ $0x3c208c16d87cfd47, R10
    SUBQ  R10, DX
    MOVQ $0x97816a916871ca8d, R10
    SBBQ  R10, DI
    MOVQ $0xb85045b68181585d, R10
    SBBQ  R10, R8
    MOVQ $0x30644e72e131a029, R10
    SBBQ  R10, R9
    JCS t_is_smaller // no borrow, we return t
    
    // borrow is set, we return u
    MOVQ DX, (AX)
    MOVQ DI, 8(AX)
    MOVQ R8, 16(AX)
    MOVQ R9, 24(AX)
    RET
    
    t_is_smaller:
    MOVQ CX, 0(AX)
    MOVQ BX, 8(AX)
    MOVQ BP, 16(AX)
    MOVQ SI, 24(AX)
    RET
    
    no_adx:
    // for i=0 to N-1
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 0
    
    // A, t[0] = x[0] * x[0] + t[0]
    MOVQ 0(DI), R11
    MOVQ R11, AX
    MULQ AX // x[0] * x[0]
    
    MOVQ AX, CX
    
    MOVQ DX, R8
    XORQ R12, R12
    
    // for j=i+1 to N-1
    //     p,A,t[j] = 2*x[j]*x[i] + t[j] + (p,A)
    XORQ R13, R13
    MOVQ 8(DI), AX
    MULQ R11
    ADDQ AX, AX
    ADCQ DX, DX
    ADCQ $0, R13
    
    ADDQ R8, AX
    ADCQ R12, DX
    
    MOVQ R13, R12
    MOVQ DX, R8
    MOVQ AX, BX
    XORQ R13, R13
    MOVQ 16(DI), AX
    MULQ R11
    ADDQ AX, AX
    ADCQ DX, DX
    ADCQ $0, R13
    
    ADDQ R8, AX
    ADCQ R12, DX
    
    MOVQ R13, R12
    MOVQ DX, R8
    MOVQ AX, BP
    XORQ R13, R13
    MOVQ 24(DI), AX
    MULQ R11
    ADDQ AX, AX
    ADCQ DX, DX
    ADCQ $0, R13
    
    ADDQ R8, AX
    ADCQ R12, DX
    
    MOVQ R13, R12
    MOVQ DX, R8
    MOVQ AX, SI
    
    // m = t[0] * q'[0]
    MOVQ $0x87d20782e4866389, R10
    IMULQ CX , R10
    
    // C, _ = t[0] + q[0]*m
    MOVQ $0x3c208c16d87cfd47, AX
    MULQ R10
    ADDQ CX ,AX
    ADCQ $0, DX
    MOVQ  DX, R9
    
    // for j=1 to N-1
    //     C, t[j-1] = q[j]*m +  t[j] + C
    MOVQ $0x97816a916871ca8d, AX
    MULQ R10
    ADDQ  BX, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, CX
    MOVQ DX, R9
    MOVQ $0xb85045b68181585d, AX
    MULQ R10
    ADDQ  BP, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BX
    MOVQ DX, R9
    MOVQ $0x30644e72e131a029, AX
    MULQ R10
    ADDQ  SI, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BP
    MOVQ DX, R9
    
    // t[N-1] = C + A
    ADDQ R9, R8
    MOVQ R8, SI
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 1
    
    // A, t[1] = x[1] * x[1] + t[1]
    MOVQ 8(DI), R11
    MOVQ R11, AX
    MULQ AX // x[1] * x[1]
    
    ADDQ AX, BX
    ADCQ $0, DX
    
    MOVQ DX, R8
    XORQ R12, R12
    
    // for j=i+1 to N-1
    //     p,A,t[j] = 2*x[j]*x[i] + t[j] + (p,A)
    XORQ R13, R13
    MOVQ 16(DI), AX
    MULQ R11
    ADDQ AX, AX
    ADCQ DX, DX
    ADCQ $0, R13
    ADDQ BP, R8
    ADCQ $0, DX
    
    ADDQ R8, AX
    ADCQ R12, DX
    
    MOVQ R13, R12
    MOVQ DX, R8
    MOVQ AX, BP
    XORQ R13, R13
    MOVQ 24(DI), AX
    MULQ R11
    ADDQ AX, AX
    ADCQ DX, DX
    ADCQ $0, R13
    ADDQ SI, R8
    ADCQ $0, DX
    
    ADDQ R8, AX
    ADCQ R12, DX
    
    MOVQ R13, R12
    MOVQ DX, R8
    MOVQ AX, SI
    
    // m = t[0] * q'[0]
    MOVQ $0x87d20782e4866389, R10
    IMULQ CX , R10
    
    // C, _ = t[0] + q[0]*m
    MOVQ $0x3c208c16d87cfd47, AX
    MULQ R10
    ADDQ CX ,AX
    ADCQ $0, DX
    MOVQ  DX, R9
    
    // for j=1 to N-1
    //     C, t[j-1] = q[j]*m +  t[j] + C
    MOVQ $0x97816a916871ca8d, AX
    MULQ R10
    ADDQ  BX, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, CX
    MOVQ DX, R9
    MOVQ $0xb85045b68181585d, AX
    MULQ R10
    ADDQ  BP, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BX
    MOVQ DX, R9
    MOVQ $0x30644e72e131a029, AX
    MULQ R10
    ADDQ  SI, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BP
    MOVQ DX, R9
    
    // t[N-1] = C + A
    ADDQ R9, R8
    MOVQ R8, SI
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 2
    
    // A, t[2] = x[2] * x[2] + t[2]
    MOVQ 16(DI), R11
    MOVQ R11, AX
    MULQ AX // x[2] * x[2]
    
    ADDQ AX, BP
    ADCQ $0, DX
    
    MOVQ DX, R8
    XORQ R12, R12
    
    // for j=i+1 to N-1
    //     p,A,t[j] = 2*x[j]*x[i] + t[j] + (p,A)
    XORQ R13, R13
    MOVQ 24(DI), AX
    MULQ R11
    ADDQ AX, AX
    ADCQ DX, DX
    ADCQ $0, R13
    ADDQ SI, R8
    ADCQ $0, DX
    
    ADDQ R8, AX
    ADCQ R12, DX
    
    MOVQ R13, R12
    MOVQ DX, R8
    MOVQ AX, SI
    
    // m = t[0] * q'[0]
    MOVQ $0x87d20782e4866389, R10
    IMULQ CX , R10
    
    // C, _ = t[0] + q[0]*m
    MOVQ $0x3c208c16d87cfd47, AX
    MULQ R10
    ADDQ CX ,AX
    ADCQ $0, DX
    MOVQ  DX, R9
    
    // for j=1 to N-1
    //     C, t[j-1] = q[j]*m +  t[j] + C
    MOVQ $0x97816a916871ca8d, AX
    MULQ R10
    ADDQ  BX, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, CX
    MOVQ DX, R9
    MOVQ $0xb85045b68181585d, AX
    MULQ R10
    ADDQ  BP, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BX
    MOVQ DX, R9
    MOVQ $0x30644e72e131a029, AX
    MULQ R10
    ADDQ  SI, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BP
    MOVQ DX, R9
    
    // t[N-1] = C + A
    ADDQ R9, R8
    MOVQ R8, SI
    
    // ---------------------------------------------------------------------------------------------
    // outter loop 3
    
    // A, t[3] = x[3] * x[3] + t[3]
    MOVQ 24(DI), R11
    MOVQ R11, AX
    MULQ AX // x[3] * x[3]
    
    ADDQ AX, SI
    ADCQ $0, DX
    
    MOVQ DX, R8
    XORQ R12, R12
    
    // for j=i+1 to N-1
    //     p,A,t[j] = 2*x[j]*x[i] + t[j] + (p,A)
    
    // m = t[0] * q'[0]
    MOVQ $0x87d20782e4866389, R10
    IMULQ CX , R10
    
    // C, _ = t[0] + q[0]*m
    MOVQ $0x3c208c16d87cfd47, AX
    MULQ R10
    ADDQ CX ,AX
    ADCQ $0, DX
    MOVQ  DX, R9
    
    // for j=1 to N-1
    //     C, t[j-1] = q[j]*m +  t[j] + C
    MOVQ $0x97816a916871ca8d, AX
    MULQ R10
    ADDQ  BX, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, CX
    MOVQ DX, R9
    MOVQ $0xb85045b68181585d, AX
    MULQ R10
    ADDQ  BP, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BX
    MOVQ DX, R9
    MOVQ $0x30644e72e131a029, AX
    MULQ R10
    ADDQ  SI, R9
    ADCQ $0, DX
    ADDQ AX, R9
    ADCQ $0, DX
    
    MOVQ R9, BP
    MOVQ DX, R9
    
    // t[N-1] = C + A
    ADDQ R9, R8
    MOVQ R8, SI
    
    JMP reduce
