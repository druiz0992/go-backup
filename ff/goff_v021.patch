diff --git a/benches/main.go b/benches/main.go
index 9c32300..21be88a 100644
--- a/benches/main.go
+++ b/benches/main.go
@@ -31,7 +31,7 @@ func main() {
 	packageName := "generated"
 	for nbWords, prime := range primes {
 		elementName := fmt.Sprintf("Element%02d", nbWords)
-		if err := cmd.GenerateFF(packageName, elementName, prime.String(), parentDir, true, true); err != nil {
+		if err := cmd.GenerateFF(packageName, elementName, prime.String(), parentDir, true,"", true); err != nil {
 			log.Fatal(elementName, err)
 		}
 	}
diff --git a/cmd/field.go b/cmd/field.go
index 755c933..a3ff014 100644
--- a/cmd/field.go
+++ b/cmd/field.go
@@ -21,6 +21,7 @@ import (
 
 type field struct {
 	PackageName          string
+        IfaceName            string
 	ElementName          string
 	Modulus              string
 	NbWords              int
@@ -56,7 +57,7 @@ type field struct {
 
 // -------------------------------------------------------------------------------------------------
 // Field data precompute functions
-func newField(packageName, elementName, modulus string, benches bool, noCollidingNames bool) (*field, error) {
+func newField(packageName, elementName, modulus string, benches bool, ifaceName string, noCollidingNames bool) (*field, error) {
 	// parse modulus
 	var bModulus big.Int
 	if _, ok := bModulus.SetString(modulus, 10); !ok {
@@ -64,11 +65,15 @@ func newField(packageName, elementName, modulus string, benches bool, noCollidin
 	}
 
 	// field info
+        if ifaceName == "" {
+           ifaceName = elementName
+        }
 	F := &field{
 		PackageName:      packageName,
 		ElementName:      elementName,
 		Modulus:          modulus,
 		Benches:          benches,
+                IfaceName:        ifaceName,
 		NoCollidingNames: noCollidingNames,
 	}
 	F.Version = Version
diff --git a/cmd/root.go b/cmd/root.go
index 94345f8..7ee11b8 100644
--- a/cmd/root.go
+++ b/cmd/root.go
@@ -23,8 +23,8 @@ import (
 	"text/template"
 
 	"github.com/consensys/bavard"
-	"github.com/consensys/goff/internal/templates/asm"
-	"github.com/consensys/goff/internal/templates/element"
+	"goff/internal/templates/asm"
+	"goff/internal/templates/element"
 	"github.com/spf13/cobra"
 )
 
@@ -41,6 +41,7 @@ var (
 	fOutputDir   string
 	fPackageName string
 	fElementName string
+	fIfaceName   string
 	fBenches     bool
 )
 
@@ -50,6 +51,7 @@ func init() {
 	rootCmd.PersistentFlags().StringVarP(&fModulus, "modulus", "m", "", "field modulus (base 10)")
 	rootCmd.PersistentFlags().StringVarP(&fOutputDir, "output", "o", "", "destination path to create output files")
 	rootCmd.PersistentFlags().StringVarP(&fPackageName, "package", "p", "", "package name in generated files")
+	rootCmd.PersistentFlags().StringVarP(&fIfaceName, "interface", "i", "", "interface name in generated files")
 	rootCmd.PersistentFlags().BoolVarP(&fBenches, "benches", "b", false, "set to true to generate montgomery multiplication (CIOS, FIPS, noCarry) benchmarks")
 
 	if bits.UintSize != 64 {
@@ -70,15 +72,15 @@ func cmdGenerate(cmd *cobra.Command, args []string) {
 	}
 
 	// generate code
-	if err := GenerateFF(fPackageName, fElementName, fModulus, fOutputDir, fBenches, false); err != nil {
+	if err := GenerateFF(fPackageName, fElementName, fModulus, fOutputDir, fBenches, fIfaceName, false); err != nil {
 		fmt.Printf("\n%s\n", err.Error())
 		os.Exit(-1)
 	}
 }
 
-func GenerateFF(packageName, elementName, modulus, outputDir string, benches bool, noCollidingNames bool) error {
+func GenerateFF(packageName, elementName, modulus, outputDir string, benches bool, ifaceName string, noCollidingNames bool) error {
 	// compute field constants
-	F, err := newField(packageName, elementName, modulus, benches, noCollidingNames)
+	F, err := newField(packageName, elementName, modulus, benches, ifaceName, noCollidingNames)
 	if err != nil {
 		return err
 	}
diff --git a/internal/templates/element/add.go b/internal/templates/element/add.go
index f8afebd..d3dfe92 100644
--- a/internal/templates/element/add.go
+++ b/internal/templates/element/add.go
@@ -2,20 +2,26 @@ package element
 
 const Add = `
 // Add z = x + y mod q
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Add( x, y *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Add( x, y {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
+
 	var carry uint64
+        var xar, yar = x.GetUint64(), y.GetUint64()
 	{{$k := sub $.NbWords 1}}
-	z[0], carry = bits.Add64(x[0], y[0], 0)
+	z[0], carry = bits.Add64(xar[0], yar[0], 0)
 	{{- range $i := .NbWordsIndexesNoZero}}
 		{{- if eq $i $.NbWordsLastIndex}}
 		{{- else}}
-			z[{{$i}}], carry = bits.Add64(x[{{$i}}], y[{{$i}}], carry)
+			z[{{$i}}], carry = bits.Add64(xar[{{$i}}], yar[{{$i}}], carry)
 		{{- end}}
 	{{- end}}
 	{{- if .NoCarry}}
-		z[{{$k}}], _ = bits.Add64(x[{{$k}}], y[{{$k}}], carry)
+		z[{{$k}}], _ = bits.Add64(xar[{{$k}}], yar[{{$k}}], carry)
 	{{- else }}
-		z[{{$k}}], carry = bits.Add64(x[{{$k}}], y[{{$k}}], carry)
+		z[{{$k}}], carry = bits.Add64(xar[{{$k}}], yar[{{$k}}], carry)
 		// if we overflowed the last addition, z >= q
 		// if z >= q, z = z - q
 		if carry != 0 {
@@ -33,20 +39,25 @@ func (z *{{.ElementName}}) Add( x, y *{{.ElementName}}) *{{.ElementName}} {
 }
 
 // AddAssign z = z + x mod q
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) AddAssign(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) AddAssign(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	var carry uint64
+        var xar = x.GetUint64()
 	{{$k := sub $.NbWords 1}}
-	z[0], carry = bits.Add64(z[0], x[0], 0)
+	z[0], carry = bits.Add64(z[0], xar[0], 0)
 	{{- range $i := .NbWordsIndexesNoZero}}
 		{{- if eq $i $.NbWordsLastIndex}}
 		{{- else}}
-			z[{{$i}}], carry = bits.Add64(z[{{$i}}], x[{{$i}}], carry)
+			z[{{$i}}], carry = bits.Add64(z[{{$i}}], xar[{{$i}}], carry)
 		{{- end}}
 	{{- end}}
 	{{- if .NoCarry}}
-		z[{{$k}}], _ = bits.Add64(z[{{$k}}], x[{{$k}}], carry)
+		z[{{$k}}], _ = bits.Add64(z[{{$k}}], xar[{{$k}}], carry)
 	{{- else }}
-		z[{{$k}}], carry = bits.Add64(z[{{$k}}], x[{{$k}}], carry)
+		z[{{$k}}], carry = bits.Add64(z[{{$k}}], xar[{{$k}}], carry)
 		// if we overflowed the last addition, z >= q
 		// if z >= q, z = z - q
 		if carry != 0 {
@@ -64,20 +75,25 @@ func (z *{{.ElementName}}) AddAssign(x *{{.ElementName}}) *{{.ElementName}} {
 }
 
 // Double z = x + x mod q, aka Lsh 1
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Double( x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Double( x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	var carry uint64
+        var xar = x.GetUint64()
 	{{$k := sub $.NbWords 1}}
-	z[0], carry = bits.Add64(x[0], x[0], 0)
+	z[0], carry = bits.Add64(xar[0], xar[0], 0)
 	{{- range $i := .NbWordsIndexesNoZero}}
 		{{- if eq $i $.NbWordsLastIndex}}
 		{{- else}}
-			z[{{$i}}], carry = bits.Add64(x[{{$i}}], x[{{$i}}], carry)
+			z[{{$i}}], carry = bits.Add64(xar[{{$i}}], xar[{{$i}}], carry)
 		{{- end}}
 	{{- end}}
 	{{- if .NoCarry}}
-		z[{{$k}}], _ = bits.Add64(x[{{$k}}], x[{{$k}}], carry)
+		z[{{$k}}], _ = bits.Add64(xar[{{$k}}], xar[{{$k}}], carry)
 	{{- else }}
-		z[{{$k}}], carry = bits.Add64(x[{{$k}}], x[{{$k}}], carry)
+		z[{{$k}}], carry = bits.Add64(xar[{{$k}}], xar[{{$k}}], carry)
 		// if we overflowed the last addition, z >= q
 		// if z >= q, z = z - q
 		if carry != 0 {
diff --git a/internal/templates/element/base.go b/internal/templates/element/base.go
index b25f601..f67aa12 100644
--- a/internal/templates/element/base.go
+++ b/internal/templates/element/base.go
@@ -32,8 +32,17 @@ const {{.ElementName}}Limbs = {{.NbWords}}
 // {{.ElementName}}Bits number bits needed to represent {{.ElementName}}
 const {{.ElementName}}Bits = {{.NbBits}}
 
+// GetUint64 returns z[0],... z[N-1]
+func (z {{.ElementName}}) GetUint64() []uint64  {
+    return z[0:]
+}
+
 // SetUint64 z = v, sets z LSB to v (non-Montgomery form) and convert z to Montgomery form
-func (z *{{.ElementName}}) SetUint64(v uint64) *{{.ElementName}} {
+{{- if eq .IfaceName .ElementName}} 
+func (z *{{.ElementName}}) SetUint64(v uint64) *{{.IfaceName}} {
+{{else}}
+func (z *{{.ElementName}}) SetUint64(v uint64) {{.IfaceName}} {
+{{end}}
 	z[0] = v
 	{{- range $i := .NbWordsIndexesNoZero}}
 		z[{{$i}}] = 0
@@ -42,15 +51,24 @@ func (z *{{.ElementName}}) SetUint64(v uint64) *{{.ElementName}} {
 }
 
 // Set z = x
-func (z *{{.ElementName}}) Set(x *{{.ElementName}}) *{{.ElementName}} {
+{{- if eq .IfaceName .ElementName}} 
+func (z *{{.ElementName}}) Set(x *{{.IfaceName}}) *{{.IfaceName}} {
+{{else}}
+func (z *{{.ElementName}}) Set(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
+        var xar = x.GetUint64()
 	{{- range $i := .NbWordsIndexesFull}}
-		z[{{$i}}] = x[{{$i}}]
+		z[{{$i}}] = xar[{{$i}}]
 	{{- end}}
 	return z
 }
 
 // SetZero z = 0
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) SetZero() *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) SetZero() {{.IfaceName}} {
+{{end}}
 	{{- range $i := .NbWordsIndexesFull}}
 		z[{{$i}}] = 0
 	{{- end}}
@@ -58,7 +76,11 @@ func (z *{{.ElementName}}) SetZero() *{{.ElementName}} {
 }
 
 // SetOne z = 1 (in Montgomery form)
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) SetOne() *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) SetOne() {{.IfaceName}} {
+{{end}}
 	{{- range $i := .NbWordsIndexesFull}}
 		z[{{$i}}] = {{index $.One $i}}
 	{{- end}}
@@ -67,17 +89,22 @@ func (z *{{.ElementName}}) SetOne() *{{.ElementName}} {
 
 
 // Neg z = q - x 
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Neg( x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Neg( x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	if x.IsZero() {
 		return z.SetZero()
 	}
 	var borrow uint64
-	z[0], borrow = bits.Sub64({{index $.Q 0}}, x[0], 0)
+        var xar = x.GetUint64()
+	z[0], borrow = bits.Sub64({{index $.Q 0}}, xar[0], 0)
 	{{- range $i := .NbWordsIndexesNoZero}}
 		{{- if eq $i $.NbWordsLastIndex}}
-			z[{{$i}}], _ = bits.Sub64({{index $.Q $i}}, x[{{$i}}], borrow)
+			z[{{$i}}], _ = bits.Sub64({{index $.Q $i}}, xar[{{$i}}], borrow)
 		{{- else}}
-			z[{{$i}}], borrow = bits.Sub64({{index $.Q $i}}, x[{{$i}}], borrow)
+			z[{{$i}}], borrow = bits.Sub64({{index $.Q $i}}, xar[{{$i}}], borrow)
 		{{- end}}
 	{{- end}}
 	return z
@@ -85,7 +112,11 @@ func (z *{{.ElementName}}) Neg( x *{{.ElementName}}) *{{.ElementName}} {
 
 
 // Div z = x*y^-1 mod q 
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Div( x, y *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Div( x, y {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	var yInv {{.ElementName}}
 	yInv.Inverse( y)
 	z.Mul( x, &yInv)
@@ -93,8 +124,13 @@ func (z *{{.ElementName}}) Div( x, y *{{.ElementName}}) *{{.ElementName}} {
 }
 
 // Equal returns z == x
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Equal(x *{{.ElementName}}) bool {
-	return {{- range $i :=  reverse .NbWordsIndexesNoZero}}(z[{{$i}}] == x[{{$i}}]) &&{{end}}(z[0] == x[0])
+{{else}}
+func (z *{{.ElementName}}) Equal(x {{.IfaceName}}) bool {
+{{end}}
+        var xar = x.GetUint64()
+	return {{- range $i :=  reverse .NbWordsIndexesNoZero}}(z[{{$i}}] == xar[{{$i}}]) &&{{end}}(z[0] == xar[0])
 }
 
 // IsZero returns z == 0
@@ -120,7 +156,11 @@ func {{toLower .ElementName}}ModulusBigInt() *big.Int {
 
 // Inverse z = x^-1 mod q 
 // note: allocates a big.Int (math/big)
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Inverse( x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Inverse( x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	var _xNonMont big.Int
 	x.ToBigIntRegular( &_xNonMont)
 	_xNonMont.ModInverse(&_xNonMont, {{toLower .ElementName}}ModulusBigInt())
@@ -133,7 +173,11 @@ func (z *{{.ElementName}}) Inverse( x *{{.ElementName}}) *{{.ElementName}} {
 // Inverse z = x^-1 mod q 
 // Algorithm 16 in "Efficient Software-Implementation of Finite Fields with Applications to Cryptography"
 // if x == 0, sets and returns z = x 
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Inverse(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Inverse(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	if x.IsZero() {
 		return z.Set(x)
 	}
@@ -153,7 +197,7 @@ func (z *{{.ElementName}}) Inverse(x *{{.ElementName}}) *{{.ElementName}} {
 	// r = 0
 	r := {{.ElementName}}{}
 
-	v := *x
+	v := x.GetUint64()
 
 	var carry, borrow, t, t2 uint64
 	var bigger, uIsOne, vIsOne bool
@@ -205,7 +249,11 @@ func (z *{{.ElementName}}) Inverse(x *{{.ElementName}}) *{{.ElementName}} {
 {{ end }}
 
 // SetRandom sets z to a random element < q
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) SetRandom() *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) SetRandom() {{.IfaceName}} {
+{{end}}
 	bytes := make([]byte, {{mul 8 .NbWords}})
 	io.ReadFull(rand.Reader, bytes)
 	{{- range $i :=  .NbWordsIndexesFull}}
@@ -223,36 +271,16 @@ func (z *{{.ElementName}}) SetRandom() *{{.ElementName}} {
 {{ else}}
 
 // One returns 1 (in montgommery form)
-func One() {{.ElementName}} {
-	var one {{.ElementName}}
+{{- if eq .IfaceName .ElementName}} 
+func (z {{.ElementName}}) One()  *{{.ElementName}} {
+{{else}}
+func (z {{.ElementName}}) One()  {{.IfaceName}} {
+{{end}}
+	one := z
 	one.SetOne()
-	return one
+	return &one
 }
 
-// FromInterface converts i1 from uint64, int, string, or {{.ElementName}}, big.Int into {{.ElementName}}
-// panic if provided type is not supported
-func FromInterface(i1 interface{}) {{.ElementName}} {
-	var val {{.ElementName}}
-
-	switch c1 := i1.(type) {
-	case uint64:
-		val.SetUint64(c1)
-	case int:
-		val.SetString(strconv.Itoa(c1))
-	case string:
-		val.SetString(c1)
-	case big.Int:
-		val.SetBigInt(&c1)
-	case {{.ElementName}}:
-		val = c1
-	case *{{.ElementName}}:
-		val.Set(c1)
-	default:
-		panic("invalid type")
-	}
-
-	return val
-}
 {{end}}
 
 
diff --git a/internal/templates/element/conv.go b/internal/templates/element/conv.go
index abaf90e..f23615d 100644
--- a/internal/templates/element/conv.go
+++ b/internal/templates/element/conv.go
@@ -4,7 +4,11 @@ package element
 const FromMont = `
 // FromMont converts z in place (i.e. mutates) from Montgomery to regular representation
 // sets and returns z = z * 1
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) FromMont() *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) FromMont() {{.IfaceName}} {
+{{end}}
 
 	// the following lines implement z = z * 1
 	// with a modified CIOS montgomery multiplication
@@ -28,7 +32,12 @@ func (z *{{.ElementName}}) FromMont() *{{.ElementName}} {
 const Conv = `
 // ToMont converts z to Montgomery form
 // sets and returns z = z * r^2
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) ToMont() *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) ToMont() {{.IfaceName}} {
+{{end}}
+
 	var rSquare = {{.ElementName}}{
 		{{- range $i := .RSquare}}
 		{{$i}},{{end}}
@@ -37,8 +46,13 @@ func (z *{{.ElementName}}) ToMont() *{{.ElementName}} {
 }
 
 // ToRegular returns z in regular form (doesn't mutate z)
+{{- if eq .IfaceName .ElementName}} 
 func (z {{.ElementName}}) ToRegular() {{.ElementName}} {
 	return *z.FromMont()
+{{else}}
+func (z {{.ElementName}}) ToRegular() {{.IfaceName}} {
+	return z.FromMont()
+{{end}}
 }
 
 // String returns the string form of an {{.ElementName}} in Montgomery form
@@ -47,6 +61,35 @@ func (z *{{.ElementName}}) String() string {
 	return z.ToBigIntRegular(&_z).String()
 }
 
+// ToByte returns the byte form of an {{.ElementName}} in Regular form
+func (z {{.ElementName}}) ToByte() []byte {
+{{- if eq .IfaceName .ElementName}} 
+	t := z.ToRegular()
+{{else}}
+	t := z.ToRegular().(*{{.ElementName}})
+{{end}}
+	var _z []byte
+	_z1 := make([]byte,8)
+	{{- range $i := .NbWordsIndexesFull}}
+		binary.LittleEndian.PutUint64(_z1, t[{{$i}}])
+                _z = append(_z,_z1...)
+	{{- end}}
+	return _z
+}
+
+// FromByte returns the byte form of an {{.ElementName}} in Regular form (mutates z)
+{{- if eq .IfaceName .ElementName}} 
+func (z *{{.ElementName}}) FromByte(x []byte) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) FromByte(x []byte) {{.IfaceName}} {
+{{end}}
+	{{- range $i := .NbWordsIndexesFull}}
+		z[{{$i}}] = binary.LittleEndian.Uint64(x[{{$i}}*8:({{$i}}+1)*8])
+	{{- end}}
+        return z.ToMont()
+}
+
+
 // ToBigInt returns z as a big.Int in Montgomery form 
 func (z *{{.ElementName}}) ToBigInt(res *big.Int) *big.Int {
 	bits := (*[{{.NbWords}}]big.Word)(unsafe.Pointer(z))
@@ -61,7 +104,11 @@ func (z {{.ElementName}}) ToBigIntRegular(res *big.Int) *big.Int {
 }
 
 // SetBigInt sets z to v (regular form) and returns z in Montgomery form
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) SetBigInt(v *big.Int) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) SetBigInt(v *big.Int) {{.IfaceName}} {
+{{end}}
 	z.SetZero()
 
 	zero := big.NewInt(0)
@@ -93,7 +140,11 @@ func (z *{{.ElementName}}) SetBigInt(v *big.Int) *{{.ElementName}} {
 }
 
 // SetString creates a big.Int with s (in base 10) and calls SetBigInt on z
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) SetString( s string) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) SetString( s string) {{.IfaceName}} {
+{{end}}
 	x, ok := new(big.Int).SetString(s, 10)
 	if !ok {
 		panic("{{.ElementName}}.SetString failed -> can't parse number in base10 into a big.Int")
diff --git a/internal/templates/element/exp.go b/internal/templates/element/exp.go
index 0e45e1d..8fc5c74 100644
--- a/internal/templates/element/exp.go
+++ b/internal/templates/element/exp.go
@@ -4,7 +4,11 @@ const Exp = `
 // Exp z = x^exponent mod q
 // (not optimized)
 // exponent (non-montgomery form) is ordered from least significant word to most significant word
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Exp(x {{.ElementName}}, exponent ...uint64) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Exp(x {{.IfaceName}}, exponent ...uint64) {{.IfaceName}} {
+{{end}}
 	r := 0
 	msb := 0
 	for i := len(exponent) - 1; i>=0; i-- {
@@ -20,13 +24,22 @@ func (z *{{.ElementName}}) Exp(x {{.ElementName}}, exponent ...uint64) *{{.Eleme
 		return z.SetOne()
 	}
 
+        {{- if eq .IfaceName .ElementName}} 
 	z.Set(&x)
+        {{else}}
+	z.Set(x)
+        {{end}}
 
 	l := msb - 2
 	for i := l; i >= 0; i-- {
 		z.Square(z)
 		if exponent[i / 64]&(1<<uint(i%64)) != 0 {
+                        {{- if eq .IfaceName .ElementName}} 
 			z.MulAssign(&x)
+                        {{else}}
+			z.MulAssign(x)
+                        {{end}}
+ 
 		}
 	}
 	return z
diff --git a/internal/templates/element/mul.go b/internal/templates/element/mul.go
index a52163c..c37a1bc 100644
--- a/internal/templates/element/mul.go
+++ b/internal/templates/element/mul.go
@@ -11,11 +11,16 @@ import "math/bits"
 
 // Mul z = x * y mod q
 // see https://hackmd.io/@zkteam/modular_multiplication
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Mul(x, y *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Mul(x, y {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
+        var xar, yar = x.GetUint64(), y.GetUint64()
 	{{ if .NoCarry}}
-		{{ template "mul_nocarry" dict "all" . "V1" "x" "V2" "y"}}
+		{{ template "mul_nocarry" dict "all" . "V1" "xar" "V2" "yar"}}
 	{{ else }}
-		{{ template "mul_cios" dict "all" . "V1" "x" "V2" "y" "NoReturn" false}}
+		{{ template "mul_cios" dict "all" . "V1" "xar" "V2" "yar" "NoReturn" false}}
 	{{ end }}
 	{{ template "reduce" . }}
 	return z 
@@ -23,11 +28,16 @@ func (z *{{.ElementName}}) Mul(x, y *{{.ElementName}}) *{{.ElementName}} {
 
 // MulAssign z = z * x mod q
 // see https://hackmd.io/@zkteam/modular_multiplication
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) MulAssign(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) MulAssign(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
+        var xar = x.GetUint64()
 	{{ if .NoCarry}}
-		{{ template "mul_nocarry" dict "all" . "V1" "z" "V2" "x"}}
+		{{ template "mul_nocarry" dict "all" . "V1" "z" "V2" "xar"}}
 	{{ else }}
-		{{ template "mul_cios" dict "all" . "V1" "z" "V2" "x" "NoReturn" false}}
+		{{ template "mul_cios" dict "all" . "V1" "z" "V2" "xar" "NoReturn" false}}
 	{{ end }}
 	{{ template "reduce" . }}
 	return z 
@@ -35,11 +45,16 @@ func (z *{{.ElementName}}) MulAssign(x *{{.ElementName}}) *{{.ElementName}} {
 
 {{- if eq .ASM false }}
 // MulAssign{{.ElementName}} z = z * x mod q
+{{- if eq .IfaceName .ElementName}} 
 func MulAssign{{.ElementName}}(z,x *{{.ElementName}}) {
+{{else}}
+func MulAssign{{.ElementName}}(z,x {{.IfaceName}}) {
+{{end}}
+        var xar = x.GetUint64()
 	{{ if .NoCarry}}
-		{{ template "mul_nocarry" dict "all" . "V1" "z" "V2" "x"}}
+		{{ template "mul_nocarry" dict "all" . "V1" "z" "V2" "xar"}}
 	{{ else }}
-		{{ template "mul_cios" dict "all" . "V1" "z" "V2" "x" "NoReturn" true}}
+		{{ template "mul_cios" dict "all" . "V1" "z" "V2" "xar" "NoReturn" true}}
 	{{ end }}
 	{{ template "reduce" . }}
 }
diff --git a/internal/templates/element/mul_amd64.go b/internal/templates/element/mul_amd64.go
index d35dc7f..2b5ef01 100644
--- a/internal/templates/element/mul_amd64.go
+++ b/internal/templates/element/mul_amd64.go
@@ -9,17 +9,35 @@ func MulAssign{{.ElementName}}(res,y *{{.ElementName}})
 
 // Mul z = x * y mod q (constant time)
 // see https://hackmd.io/@zkteam/modular_multiplication
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Mul(x, y *{{.ElementName}}) *{{.ElementName}} {
 	res := *x
 	MulAssign{{.ElementName}}(&res, y)
 	z.Set(&res)
 	return z
 }
+{{else}}
+func (z *{{.ElementName}}) Mul(x, y {{.IfaceName}}) {{.IfaceName}} {
+	res := *x.(* {{.ElementName}})
+	MulAssign{{.ElementName}}(&res, y.(* {{.ElementName}}))
+	z.Set(&res)
+	return z
+}
+{{end}}
 
 // MulAssign z = z * x mod q (constant time)
 // see https://hackmd.io/@zkteam/modular_multiplication
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) MulAssign(x *{{.ElementName}}) *{{.ElementName}} {
+
 	MulAssign{{.ElementName}}(z, x)
 	return z 
 }
+{{else}}
+func (z *{{.ElementName}}) MulAssign(x {{.IfaceName}}) {{.IfaceName}} {
+
+	MulAssign{{.ElementName}}(z, x.(* {{.ElementName}}))
+	return z 
+}
+{{end}}
 `
diff --git a/internal/templates/element/sqrt.go b/internal/templates/element/sqrt.go
index 099993f..0e9365d 100644
--- a/internal/templates/element/sqrt.go
+++ b/internal/templates/element/sqrt.go
@@ -5,9 +5,15 @@ const Sqrt = `
 func (z *{{.ElementName}}) Legendre() int {
 	var l {{.ElementName}}
 	// z^((q-1)/2)
+       {{- if eq .IfaceName .ElementName}} 
 	l.Exp(*z, {{range $i := .LegendreExponent}}
 		{{$i}},{{end}}
 	)
+        {{else}}
+	l.Exp(z, {{range $i := .LegendreExponent}}
+		{{$i}},{{end}}
+	)
+        {{end}}
 	
 	if l.IsZero() {
 		return 0
@@ -23,14 +29,24 @@ func (z *{{.ElementName}}) Legendre() int {
 // Sqrt z = √x mod q
 // if the square root doesn't exist (x is not a square mod q)
 // Sqrt leaves z unchanged and returns nil
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Sqrt(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Sqrt(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	{{- if .SqrtQ3Mod4}}
 		// q ≡ 3 (mod 4)
 		// using  z ≡ ± x^((p+1)/4) (mod q)
 		var y, square {{.ElementName}}
+                {{- if eq .IfaceName .ElementName}} 
 		y.Exp(*x, {{range $i := .SqrtQ3Mod4Exponent}}
 			{{$i}},{{end}}
 		)
+                {{else}}
+		y.Exp(x, {{range $i := .SqrtQ3Mod4Exponent}}
+			{{$i}},{{end}}
+		)
+                {{end}}
 		// as we didn't compute the legendre symbol, ensure we found y such that y * y = x
 		square.Square(&y)
 		if square.Equal(x) {
@@ -43,9 +59,15 @@ func (z *{{.ElementName}}) Sqrt(x *{{.ElementName}}) *{{.ElementName}} {
 		var one, alpha, beta, tx, square {{.ElementName}}
 		one.SetOne()
 		tx.Double(x)
+                {{- if eq .IfaceName .ElementName}} 
 		alpha.Exp(tx, {{range $i := .SqrtAtkinExponent}}
 			{{$i}},{{end}}
 		)
+                {{else}}
+		alpha.Exp(tx, {{range $i := .SqrtAtkinExponent}}
+			{{$i}},{{end}}
+		)
+                {{end}}
 		beta.Square(&alpha).
 			MulAssign(&tx).
 			SubAssign(&one).
@@ -65,9 +87,15 @@ func (z *{{.ElementName}}) Sqrt(x *{{.ElementName}}) *{{.ElementName}} {
 
 		var y, b,t, w  {{.ElementName}}
 		// w = x^((s-1)/2))
+                {{- if eq .IfaceName .ElementName}} 
 		w.Exp(*x, {{range $i := .SqrtSMinusOneOver2}}
 			{{$i}},{{end}}
 		)
+                {{else}}
+		w.Exp(x, {{range $i := .SqrtSMinusOneOver2}}
+			{{$i}},{{end}}
+		)
+                {{end}}
 
 		// y = x^((s+1)/2)) = w * x
 		y.Mul(x, &w)
diff --git a/internal/templates/element/square.go b/internal/templates/element/square.go
index 1181af4..3264a09 100644
--- a/internal/templates/element/square.go
+++ b/internal/templates/element/square.go
@@ -12,13 +12,18 @@ import "math/bits"
 
 // Square z = x * x mod q
 // see https://hackmd.io/@zkteam/modular_multiplication
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Square(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Square(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
+        var xar = x.GetUint64()
 	{{if .NoCarrySquare}}
-		{{ template "square" dict "all" . "V1" "x"}}
+		{{ template "square" dict "all" . "V1" "xar"}}
 		{{ template "reduce" . }}
 		return z 
 	{{else if .NoCarry}}
-		{{ template "mul_nocarry" dict "all" . "V1" "x" "V2" "x"}}
+		{{ template "mul_nocarry" dict "all" . "V1" "xar" "V2" "xar"}}
 		{{ template "reduce" . }}
 		return z 
 	{{else }}
diff --git a/internal/templates/element/square_amd64.go b/internal/templates/element/square_amd64.go
index 25d2c13..4f7e0d5 100644
--- a/internal/templates/element/square_amd64.go
+++ b/internal/templates/element/square_amd64.go
@@ -9,12 +9,20 @@ func Square{{.ElementName}}(res,x *{{.ElementName}})
 
 // Square z = x * x mod q
 // see https://hackmd.io/@zkteam/modular_multiplication
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Square(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Square(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	// if z != x {
 	// 	z.Set(x)
 	// }
 	// MulAssign{{.ElementName}}(z, x)
+        {{- if eq .IfaceName .ElementName}} 
 	Square{{.ElementName}}(z, x)
+        {{else}}
+	Square{{.ElementName}}(z, x.(*{{.ElementName}}))
+        {{end}}
 	return z
 }
 
diff --git a/internal/templates/element/sub.go b/internal/templates/element/sub.go
index 2a4fe16..4d1af0d 100644
--- a/internal/templates/element/sub.go
+++ b/internal/templates/element/sub.go
@@ -2,11 +2,16 @@ package element
 
 const Sub = `
 // Sub  z = x - y mod q
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) Sub( x, y *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) Sub( x, y {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	var b uint64
-	z[0], b = bits.Sub64(x[0], y[0], 0)
+        var xar, yar = x.GetUint64(), y.GetUint64()
+	z[0], b = bits.Sub64(xar[0], yar[0], 0)
 	{{- range $i := .NbWordsIndexesNoZero}}
-		z[{{$i}}], b = bits.Sub64(x[{{$i}}], y[{{$i}}], b)
+		z[{{$i}}], b = bits.Sub64(xar[{{$i}}], yar[{{$i}}], b)
 	{{- end}}
 	if b != 0 {
 		var c uint64
@@ -23,11 +28,16 @@ func (z *{{.ElementName}}) Sub( x, y *{{.ElementName}}) *{{.ElementName}} {
 }
 
 // SubAssign  z = z - x mod q
+{{- if eq .IfaceName .ElementName}} 
 func (z *{{.ElementName}}) SubAssign(x *{{.ElementName}}) *{{.ElementName}} {
+{{else}}
+func (z *{{.ElementName}}) SubAssign(x {{.IfaceName}}) {{.IfaceName}} {
+{{end}}
 	var b uint64
-	z[0], b = bits.Sub64(z[0], x[0], 0)
+        var xar = x.GetUint64()
+	z[0], b = bits.Sub64(z[0], xar[0], 0)
 	{{- range $i := .NbWordsIndexesNoZero}}
-		z[{{$i}}], b = bits.Sub64(z[{{$i}}], x[{{$i}}], b)
+		z[{{$i}}], b = bits.Sub64(z[{{$i}}], xar[{{$i}}], b)
 	{{- end}}
 	if b != 0 {
 		var c uint64
diff --git a/internal/templates/element/tests.go b/internal/templates/element/tests.go
index fa28ee7..e175d54 100644
--- a/internal/templates/element/tests.go
+++ b/internal/templates/element/tests.go
@@ -89,7 +89,11 @@ func Test{{toUpper .ElementName}}CorrectnessAgainstBigInt(t *testing.T) {
         eDiv.Div(&e1, &e2)
         eNeg.Neg(&e1)
         eInv.Inverse(&e1)
+{{- if eq .IfaceName .ElementName}} 
 		eExp.Exp(e1, rExp)
+{{else}}
+		eExp.Exp(&e1, rExp)
+{{end}}
         eLsh.Double(&e1)
 
         // same operations with big int
@@ -142,7 +146,11 @@ func Test{{toUpper .ElementName}}CorrectnessAgainstBigInt(t *testing.T) {
 			for k := 0; k < len(bits); k++ {
 				exponent[k] = uint64(bits[k])
 			}
+                        {{- if eq .IfaceName .ElementName}} 
 			eExp2.Exp(e1, exponent...)
+                        {{else}}
+			eExp2.Exp(&e1, exponent...)
+                        {{end}}
 			bExp2.Exp(b1, b2, modulus)
 			cmpEandB(&eExp2, &bExp2, "Exp multi words")
 		}
@@ -184,7 +192,11 @@ func BenchmarkExp{{toUpper .ElementName}}(b *testing.B) {
 	benchRes{{.ElementName}}.SetRandom()
 	b.ResetTimer()
 	for i := 0; i < b.N; i++ {
+                {{- if eq .IfaceName .ElementName}} 
 		benchRes{{.ElementName}}.Exp(x, mrand.Uint64())
+                {{else}}
+		benchRes{{.ElementName}}.Exp(&x, mrand.Uint64())
+                {{end}}
 	}
 }
 
@@ -281,6 +293,7 @@ func BenchmarkMulAssign{{toUpper .ElementName}}(b *testing.B) {
 	}
 }
 
+/*
 {{ if .ASM}}
 func BenchmarkMulAssignASM{{toUpper .ElementName}}(b *testing.B) {
 	x := {{.ElementName}}{
@@ -293,6 +306,7 @@ func BenchmarkMulAssignASM{{toUpper .ElementName}}(b *testing.B) {
 		MulAssign{{.ElementName}}(&benchRes{{.ElementName}}, &x)
 	}
 }
+
 {{ if .NoCarrySquare}}
 func BenchmarkSquareASM{{toUpper .ElementName}}(b *testing.B) {
 	benchRes{{.ElementName}} = {{.ElementName}}{
@@ -306,6 +320,7 @@ func BenchmarkSquareASM{{toUpper .ElementName}}(b *testing.B) {
 }
 {{ end}}
 {{ end}}
+*/
 
 
 func Test{{toUpper .ElementName}}Asm(t *testing.T) {
diff --git a/main.go b/main.go
index 8f1c157..9881fa1 100644
--- a/main.go
+++ b/main.go
@@ -15,7 +15,7 @@
 // Package goff (go finite field) is a unix-like tool that generates fast field arithmetic in Go.
 package main
 
-import "github.com/consensys/goff/cmd"
+import "goff/cmd"
 
 func main() {
 	cmd.Execute()
